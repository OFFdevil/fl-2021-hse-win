# 0 - описание языка
- В первой строке написано: `<number of vertices><space>}`
- На второй строке написан алфавит: `#<letter1># <letter2>#` ...
- На следующих n (количество вершин, которое было введено на прошлой строк) строках будут задаваться вершины (состояние вершин: 0 - начальна вершина, 1 - обычая вершина, 2 - терминальная) :
```<vertex number><space>]<space>-><space><vertex number><space>|```
- На следующих строчках будет содержаться информация про рёбра. Символы алфавита, по которым будет происходить переход, будут окружены символом `#`, а также все специальные символы, если они содержатся в алфавите, должны быть экранированы (`# -> \# ; \s -> \\s ; \n -> \\n; \ -> \\`) : 
```<from>,<to><space>:<space>#<letter from alphabet>#<space>(some more transitions)```
# Примеры входных данных:

```
3 }
#1# #2# #3#
1 ] -> 0 |
2 ] -> 2 |
1,2 : #1# #2# #3#
```
---
```
3 }
#1\## #2   \## #\##
1 ] -> 0 |
2 ] -> 2 |
1,2 : #1\## #2   \## #\##
```
---
```
4 }
#\\Егор \\Суворов\\# #\\Александр \\Омельченко\\# #\\первокурсник\\# #\\второкурсник\\#
1 ] -> 0 |
2 ] -> 2 |
10 ] -> 1 |
11 ] -> 1 |
1,10 : #\\Егор \\Суворов\\# 
1,2 : #\\Александр \\Омельченко\\# 
1,11 : #\\первокурсник\\# #\\второкурсник\\#
```
---

UPD1: в язык добавлено новое важное условие: во второй строчке должен быть описан алфавит!
# 1
## Петроченков Михаил
...

## Полупанова Анна
### Описание автоматов на данном языке:
1. Задача: написать автомат, который определяет содержит строка символ 'A' или нет. Алфавит: 'A'
```
 [40~10]
start q0
terminal q1
transition (q0 -> q1, {40~10})
transition (q1 -> q1, {40~10})
``` 
2. Задача: написать автомат, который определяет, число больше 9 или нет. Алфавит: '0','1','2','3','4','5','6','7','8','9'
```
[00~30] [00~31] [00~32] [00~33] [00~34] [00~35] [00~36] [00~37] [00~38] [00~39] 
start q0
terminal q1
transition (q0 -> q0, {00~30})
transition (q0 -> s0, {00~31,00~32,00~33,00~34,00~35,00~36,00~37,00~38,00~39})
transition (s0 -> q1, {00~30,00~31,00~32,00~33,00~34,00~35,00~36,00~37,00~38,00~39})
```
### Обратная связь по языку
1. Язык описан хорошо, сразу понятна его структура и как задавать автоматы на нём. Приведён хороший пример, посмотев на который, можно самому понять как задавать автомат.
2. Плюсы:
   1. Сразу известен алфавит, который описан на 1 строчке
   2. Каждое слово в начале строки однозначно задаёт том, о чём будет написано в данной строке
   3. Каждый символ однозначно задаётся из-за того, что он задан в Unicode, поэтому нет проблем в "\" или другими специальными символами
   Минусы:
   1. Нужно знать как задаётся символ в Unicode и если просто читать переходы, то не сразу понячно, а по какому это символу переход происходит
   2. Сначала я понял, что литерал не может состоять больше чем из одного символа, т.к. в unicode все первые картинки, которые мне выдавал google, приводил в пример символы, которые имеют четырёхзначное представление в unicode. Но потом, разобрался, что можно также через '~' последовательность из символов задавать
3. Есть лексер. В целом всё хорошо. Есть некоторые недочеты, в том, что я могу просто не заключить в скобки символы алфавита, по которым переход, и он не выдаст ошибку. 
```
[30~30]
start q0
terminal s0
transition (q0 -> s0, 30~30)
```
4. Может моя вкусовщина, но мне бы хотелось писалось в какой строчке ошибка, т.к. мне выводится ошибка "Incorrect vertex name", но непонятно, что именно ему понравилось, какая именно вершина ему не понравилась? где именно?
5. Ошибки:
   1. На следующий ввод, выдаёт, что есть вершина с названием 's0,'. Скорее всего эта неточность была найдена автором и изменена, но забыто обновление языка. (я это нашёл, т.к. проверил входные данные от автора, на который тестировался анализатор)

   input:
   ```
    [30~30]
    start q0
    terminal s0
    transition (q0 -> s0, {30~30})
   ```
   output:
   ```
   The list of words: 
   The list of vertexes: 
   q0: start
   s0: terminal
   s0,: non_terminal
   The list of edges: 
   ```
   2. Не думаю, что если неккоректное имя и анализатор выводит, что оно неккоретно, то должна создаваться вершина с таким именем. Поэтому на следующем вход должен не создавать вершину, а он создаёт: 
   
   input:
   ```
    [30~30]
    start 1q0
    terminal s0
    transition (q0 -> s0 , {30~30})
   ```
   output:
   ```
   The list of words: 
   The list of vertexes: 
   1q0: start
   q0: non_terminal
   s0: terminal
   The list of edges: 
   Start vertex: q0. End vertex: s0. Transition words: 
   ```
   3. Синтаксический анализатор не выводит ошибку о том, что не существует символа

   input:
   ```
   [30~30]
   start q0
   terminal s0
   transition (q0 -> s0 , {301~30})
   ```
   output:
   ```
   The list of words: 
   The list of vertexes: 
   q0: start
   s0: terminal
   The list of edges: 
   Start vertex: q0. End vertex: s0. Transition words: -

   ```
# 2
Синтаксический анализатор `language/main.cpp`.

Чтобы запустить тесты нужно написать в консоли:
```
g++-10 -std=c++17 main.cpp -o main
./main <name-test>
```

Все ошибки выводятся в консоль: `<строчка>:<символ>: <сообщение о ошибке>`
# 3
Чтобы проверить, что анализатор корректно работает и может анализировать разные графы, нужно запустить тесты с соответсвуещем именем и тогда создатся файл, в котором будет проверена конкретная особенность автомата. В папке `languages` приведены тесты и вывод в файлик с именем, который отличается на `.out` от файла ввода (пример: файл ввода `input.txt` -> файл вывода `input.txt.out`), после запуска программы на данном файле 